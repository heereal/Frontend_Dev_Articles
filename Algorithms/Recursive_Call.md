# 재귀 호출 (Recursive Call)
> [함수 호출의 원리 및 재귀호출](http://10bun.tv/beginner/episode-4/)

<br/>

## 일반적인 함수 호출 및 리턴 과정
![pic-1 fbffa400](https://github.com/heereal/Frontend_Dev_Articles/assets/117061017/6b6e0549-48cb-4226-9b58-57c6ff063296)

1. `main()` 함수 중간에 `함수 A`를 호출하면서 코드 진행이 `함수 A`의 처음 부분으로 옮겨간다.
2. `함수 A` 중간에 `함수 B`를 호출하면서 코드 진행이 `함수 B`의 처음 부분으로 옮겨간다.
3. `함수 B` 중간에 `함수 C`를 호출하면서 코드 진행이 `함수 C`의 처음 부분으로 옮겨간다.
4. `함수 C`의 모든 실행을 마치면 `함수 B`에서 자신을 호출했던 다음 줄(return)로 돌아간다.
5. `함수 B`의 모든 실행을 마치면 `함수 A`에서 자신을 호출했던 다음 줄(return)로 돌아간다.
6. `함수 A`의 모든 실행을 마치면 `main()` 함수에서 자신을 호출했던 다음 줄(return)로 돌아간다. 

<br/>

## 재귀함수의 호출 및 리턴 과정
![pic-3 15b299dc](https://github.com/heereal/Frontend_Dev_Articles/assets/117061017/2350d6f4-48f1-462f-a116-959f795e75f3)

- 재귀함수 내에서 자신을 호출하는 경우 **호출된 함수는 메모리에 새로운 공간을 확보해서 매번 전혀 다른 공간에서 작업을 진행**한다.
- `main()` 함수에서 처음 재귀함수를 실행했을 때 `재귀함수 1`이라는 메모리 공간이 생겨서 작업을 진행하다가 다시 재귀함수를 실행한다면 새로 `재귀함수 2`이라는 메모리 공간이 생성되는 방식이다.
- 이런 방식을 반복하다보면 같은 코드가 메모리 공간만 옮겨다니면서 무한히 반복되기 때문에 메모리가 부족할 때까지 멈추지 않고 반복하다가 프로그램이 종료되기 때문에 재귀함수를 작성할 때에는 언제 멈춰야 할지 **탈출조건이 필요**하다.
- 위의 그림에서 `재귀함수 3`은 탈출조건을 만나서 실행이 멈추게 되고, 이후 이전 함수로 복귀하여 나머지 코드를 진행하고 다시 이전 함수로 복귀하는 과정이 계속 진행된다.

<br/>

## 재귀호출에 대한 간단한 예
```cpp
int sum(int n)
{
	// 탈출 조건
	if (1 == n) {
		return 1;

	// 자신보다 1만큼 작은 숫자를 분신을 만들어서 계산을 시킨다.
	// 분신이 계산을 마치면 자신의 현재 값을 거기에 더한다.
	} else {
		return sum(n-1) + n;
	}
}
```
- `sum()` 함수는 1부터 n까지의 합을 계산하는 알고리즘이 구현되어 있다.
- 자신을 다시 호출하면서 자신이 호출 되었을 때 n 값보다 1만큼 작은 숫자를 인자로 보낸다.

<br/>

![pic-4 0c2bbb4c](https://github.com/heereal/Frontend_Dev_Articles/assets/117061017/df50fec3-9cb3-455f-8689-7c8e0f4dfc45)

1. `sum(3)`이 실행되면 n의 값이 1이 아니기 때문에 `sum(3-1)` 즉 `sum(2)`를 호출한다.
2. `sum(2)`이 실행되면 n의 값이 1이 아니기 때문에 `sum(2-1)` 즉 `sum(1)`를 호출한다.
3. `sum(1)`이 실행되면 `n == 1` 조건이 만족되어 1을 리턴한다.
4. `sum(2)`는 `sum(1)`에서 리턴받은 1에다가 자신의 2를 더해서 3을 리턴한다.
5. `sum(3)`은 `sum(2)`에서 리턴받은 3에다가 자신의 3을 더해서 6을 리턴한다.

